Informacion sobre el profesor Adolfo que es el que dicta el curso:
El profesor del curso de lenguajes formales es Adolfo Andres Castro Sanchez es ingeniero electronico,dicta el curso de 6 a 9 de la noche los lunes y miercoles , es un profesor muy bueno y tiene tambien estos titulos:
Adolfo tambien es Especialista en Telecomunicaciones , Magister en Tecnologías de la
Información y la Comunicación, Certificaciones:
Auditor interno ISO:27001-2013
 Dynatrace Associate: Plataforma de
observabilidad y alertamiento de
servicios de TI
Otros:
 Senior en diseño de sistemas
embebidos.
 Conocimientos en IoT
 I+D+i: Redes Inalámbricas de
Sensores
 Manejo de la teoría de Sistemas de
instrumentación y control
 Diseñador y manejo de la Teoría de
las comunicaciones
 Manejo de sistemas de bajo nivel

El profesor no ha publicado ningun libro pero tiene estas experiencias: 
Experiencia
Docencia:
– Lógica de programación y algoritmia
– Lenguajes de programación (C,
Python, java, javascript, lenguaje G)
– Microprocesadores
– Programación de sistemas
embebidos
– Análisis de Fourier y Laplace
– Sistemas de instrumentación y
control
– Sistemas de comunicaciones
analógicos y digitales
– Electrónica analógica, digital, de
potencia, industrial.
– Lenguajes Formales y Compiladores
Industria:
– Analista de Observabilidad,
monitoreo y alertamiento de
servicios de TI
Investigación I+D+i:
– Diseño de sistemas de alertas tempranas
en convenio con la alcaldía de Tunja –
Boyacá
– Ponencias en IoT
– Diseño e implementación de redes
inalámbricas de sensores
Extensión:
– Diseño y producción de medios de
radiodifusión con fines tecnológicos.
Otros:
– Participación en procesos de
autoevaluación de programas académicos
– Diseño de programas por competencias y
Resultados de aprendizaje.
– Representante académico ante órganos de
controles institucionales internos

Informacion del curso:

Objetivos del curso de lenguajes formales:
General
Estudiar los principios de los lenguajes formales, sus técnicas y aplicación en la construcción
de compiladores, con el fin de entender traductores de lenguajes de programación
– Específicos
Definir, entender y utilizar:
Lenguajes formales (Modelo: Conjunto de reglas)
Gramáticas formales (Estructuración del lenguaje)
Autómatas de estado finito: (Herramienta o artefacto) Reconocimiento de cadenas
Analizadores sintácticos ascendentes y descendentes. (Aplicación)
Analizador semático

ESTA ES TODA LA INFORMACION DEL CURSO DE LAS DIAPOSITIVAS DEL PROFESOR :
LENGUAJES
FORMALES
¿Qué son?
Composición y ejemplo
Compuesto por
– Alfabeto: formar cadenas
– Lenguaje: conjunto de cadenas
– Operaciones
Lenguajes de alto nivel son lenguajes formales
Modelos de computación
Los lenguajes formales están relacionados con los modelos de computacionales:
– Autómatas DFA y NDFA
– Autómatas de pila
– Máquinas de Turing
Ejemplos de Modelos
Representaciones de
estructuras
■ Definir las siguientes estructuras en el contexto de los lenguajes formales:
– Gramáticas
– Expresiones regulares
Demostraciones formales
■ Demostración Deductivas
Consiste en una secuencia de afirmaciones, oraciones, declaraciones cuya verdad nos lleva
desde alguna afirmación inicial, llamada hipótesis hasta una conclusión. A continuación, dos
ejemplos:
𝑠𝑖 𝑥 ≥ 4, 𝑒𝑛𝑡𝑜𝑛𝑐𝑒𝑠 2𝑥 ≥ 𝑥2
Realizar en Clase:
𝑠𝑖 𝑥 𝑒𝑠 𝑙𝑎 𝑠𝑢𝑚𝑎 𝑑𝑒 𝑙𝑜𝑠 𝑐𝑢𝑎𝑑𝑟𝑎𝑑𝑜𝑠 𝑑𝑒 𝑐𝑢𝑎𝑡𝑟𝑜 𝑛ú𝑚𝑒𝑟𝑜𝑠 𝑒𝑛𝑡𝑒𝑟𝑜𝑠 𝑝𝑜𝑠𝑖𝑡𝑖𝑣𝑜𝑠, 𝑒𝑛𝑡𝑜𝑛𝑐𝑒𝑠 2𝑥 ≥ 𝑥2
Aspectos a tener en cuenta en
las demostraciones
Consultar:
■ Reducción a definiciones
■ Teoremas en otras formas
– If-Then
– If-only-if
– Not-if-then
■ Formas adiconales de demostraciones:
– Por conjuntos
– Por contradicción
– Contraejemplo
■ Demostraciones inductivas
Aplicaciones
■ Son el fundamento de los lenguajes que utilizamos
■ Usos en procesamiento de texto (data validation, data scraping, data wrangling, simple
parsing, the production of syntax highlighting systems,...)
■ Procesamiento de lenguaje natural


Ejemplos
■ Realizar la lectura y análisis de ejemplos de la lectura 2 del libro de Kozen páginas
11, 12 y 13
Indicar a qué hace referencia
la siguiente expresión
REGULAR LANGUAGE
¿Qué son?
Definition
■ A language of alphabet Σ is regular if it can be expressed by applying a finite number of
times the operations of concatenation, union, and star.
■ A regular expression (r.e.) is a string 𝑟 containing the terminal characters of alphabet Σ
and the metasymbols: · (concatenation), ∪ (union), ∗ (star), Ф (empty set), (, ); in
accordance with the following rules:
𝑟 = 𝜙 , 𝑟 = 𝑎 𝑎 ∈ Σ , 𝑟 = 𝑠 ∪ 𝑡 , 𝑟 = 𝑠 · 𝑡 , 𝑟 = (𝑠)∗
where 𝑠 and 𝑡 are r.e.
Operators Precedence
𝑺𝒕𝒂𝒓 (∗)
⇓
𝑪𝒐𝒏𝒄𝒂𝒕𝒆𝒏𝒂𝒕𝒊𝒐𝒏 (·)
⇓
𝑼𝒏𝒊𝒐𝒏 (∪)
Meaning of a Regular
Expression
■ The meaning or denotation of a r.e. 𝑟 is a language 𝐿(𝑟) over an alphabet
Σ, defined by:
■ We take Ф∗= {ε}.
Regular Expression 𝑟 Language 𝐿(𝑟)
Ф {}
𝑎 ∈ Σ {𝑎}
𝑠 ∪ 𝑡 𝐿(𝑠) ∪ 𝐿(𝑡)
𝑠 · 𝑡 𝐿(𝑠) · 𝐿(𝑡)
𝑠∗ (𝐿(𝑠))∗


Ejemplos DFA: Hallar Q,
Sigma, Start y Final
𝑸𝟑Q1
𝒂
𝒃 𝑸𝟐Q1𝑸𝟏Q1𝑸𝟎
𝒂
𝒂
𝒂, 𝒃
𝒃 𝒃
Ejemplos DFA: Dibuje el
automata y tabla de transición
■ Considere el siguiente conjunto:
𝑥𝑎𝑎𝑎𝑦 𝑥, 𝑦 ∈ 𝑎, 𝑏 ∗}
𝑥 ∈ {𝑎, 𝑏}∗ 𝑥 𝑐𝑜𝑛𝑡𝑖𝑒𝑛𝑒 𝑢𝑛 𝑠𝑢𝑏𝑠𝑡𝑟𝑖𝑛𝑔 𝑑𝑒 3 𝑎 𝑐𝑜𝑛𝑠𝑒𝑐𝑢𝑡𝑖𝑣𝑎𝑠}
Solución?
Buscar y complementar la información
en el ejemplo 3.1 del libro de Kozen
Verdadera solución, más información
ejemplo 3.2 del libro de Kozen
Ejemplos DFA:
■ Considere el siguiente conjunto:
𝑥 ∈ {0,1}∗ 𝑥 𝑟𝑒𝑝𝑟𝑒𝑠𝑒𝑛𝑡𝑎 𝑢𝑛 𝑚𝑢𝑙𝑡𝑖𝑝𝑙𝑜 𝑑𝑒 𝑡𝑟𝑒𝑠 𝑒𝑛 𝑏𝑖𝑛𝑎𝑟𝑖𝑜}
Nota: Cantidad de ceros permitidos y 𝜀 representa el número cero
Cadenas que no contengan múltiplos de 3 deben ser rechazadas


Procesamiento de un String con un NFA
[Realizar la f de transición] con la cadena
vacía como carácter y luego sin cadena
vacía
𝑸𝟏
𝒃𝒂
𝑸𝟎 𝑸𝟐
𝒂
𝜀
Expresión regular (e.r.) = (ab+aba)∗
Desarrollo NFA Anterior:
Cadena de entrada L = “abaab”
■ Rama principal: leo los primeros tres caracteres de la cadena
(𝑄0, 𝑎, 𝑄1)➔ (𝑄1, 𝑏, 𝑄2)
A partir del tercer carácter empiezo mi ruta de decisión para leer los próximos dos
caracteres que faltan y llegar al estado final o de aceptación
▪ ARBOL_RUTA_1: 𝑄2, 𝑎, 𝑄0 ➔ (𝑄0, 𝑎, 𝑄1)➔ (𝑄1, 𝑏, 𝑄2)➔ 𝑄2, 𝜀, 𝑄0 ➔ 𝑄0, 𝜀
▪ ARBOL_RUTA_2: 𝑄2, 𝜀, 𝑄0 ➔ (𝑄0, 𝑎, 𝑄1)➔ (𝑄1, 𝑎, −)
▪ Donde la ruta marcada en verde es la correcta y la marcada en rojo es la incorrecta
porque en la última transición no es capaz de reconocer el carácter “a” por lo tanto el
autómata
Ejemplo en clase: Hallar el DFA a partir del
siguiente NFA
𝑸𝟎
𝒂, 𝒃𝒃 𝑸𝟐
𝜀
𝑸𝟏
𝒂 𝒂 𝒂, 𝒃
Plantear función de transición Δ
Δ 𝒂 𝒃
→𝑄0 𝑄0 𝑄1
𝑄1𝐹 𝑄1, 𝑄2 𝑄2
𝑄2 𝑄2 𝑄2
𝟐𝒏 → 𝒆𝒔𝒕𝒂𝒅𝒐𝒔
Hallar la función de transición 𝛿
𝛅 𝒂 𝒃
∅ ∅ ∅
→ {𝑸𝟎}
{𝑸𝟏} 𝑭
{𝑸𝟐}
{𝑸𝟎, 𝑸𝟏 } 𝑭
{𝑸𝟎, 𝑸𝟐 }
{𝑸𝟏, 𝑸𝟐 } 𝑭
{𝑸𝟎, 𝑸𝟏 , 𝑸𝟐 } 𝑭
Solución:
𝛅 𝒂 𝒃
∅ ∅ ∅
→ {𝑸𝟎} {𝑸𝟎} {𝑸𝟏}
{𝑸𝟏} 𝑭 {𝑸𝟏, 𝑸𝟐} {𝑸𝟐}
{𝑸𝟐} {𝑸𝟐} {𝑸𝟐}
{𝑸𝟎, 𝑸𝟏 } 𝑭 {𝑸𝟎, 𝑸𝟏, 𝑸𝟐} {𝑸𝟏, 𝑸𝟐}
{𝑸𝟎, 𝑸𝟐 } {𝑸𝟎, 𝑸𝟐} {𝑸𝟏, 𝑸𝟐}
{𝑸𝟏, 𝑸𝟐 } 𝑭 {𝑸𝟏, 𝑸𝟐} {𝑸𝟐}
{𝑸𝟎, 𝑸𝟏 , 𝑸𝟐 } 𝑭 {𝑸𝟎, 𝑸𝟏, 𝑸𝟐} {𝑸𝟏, 𝑸𝟐}


Estudiar el caso
El Lema del Bombeo
Forma contrapositiva del Lema del
Bombeo
Conclusiones
Limitaciones
■ Incapacidad para Reconocer Lenguajes No Regulares
■ Memoria Limitada
■ Complejidad del Diseño
■ No Pueden Manejar Dependencias entre Distintas Partes de la Entrada: Relación o
dependencia entre diferentes partes de la cadena de entrada
■ No Pueden Realizar Cálculos Complejos
■ No Son Reversibles en General


Otro Ejemplo y aspectos a tener en
cuenta
begin if 𝐳 = (𝒙 + 𝟑) then 𝐲 ≔ 𝒛 else 𝐲 ≔ 𝒙 end
■ El conjunto de todas las cadenas que no contienen ningún no-terminal por la
gramática se llama lenguaje. Dichas cadenas pueden ser infinitas dadas un
conjunto de reglas finitas.
■ Existen muchas formas de derivación para una misma cadena sin embargo se dice
que una gramática es no es ambigua si esa condición no se cumple
■ Por ello la definición general de Gramáticas Libres de Contexto (CFGs) y los
lenguajes que ellos generan. El lenguaje el cual es un subconjunto de Σ∗ generado
por una CFG es denotado por 𝐿(𝐺) el cuál es llamado Lenguaje Libre de Contexto
(CFLs)
■ Los CFLs describen un conjunto infinito de cadenas en formas finitas
■ Usados en ciencia de la computación para describir las sintaxis de un lenguaje de
programación, formar expresiones aritméticas, anidar bloques begin-end, cadenas
de balanceo de paréntesis y mas
Todos los conjuntos regulares son
CFG pero no viceversa
■ Por ejemplo, los siguientes conjuntos no son regulares:
𝑎𝑛𝑏𝑛 𝑛 ≥ 0}
𝑝𝑎𝑙𝑖𝑛𝑑𝑟𝑜𝑚𝑜𝑠 𝑠𝑜𝑏𝑟𝑒 𝑎, 𝑏 = 𝑥 ∈ 𝑎, 𝑏 ∗ 𝑥 = 𝑟𝑒𝑣 𝑥}
{𝑏𝑎𝑙𝑎𝑛𝑐𝑒𝑜 𝑑𝑒 𝑝𝑎𝑟é𝑛𝑡𝑒𝑠𝑖𝑠}
Definición Formal:
Formalmente una gramática libre de contexto:
𝑮 = 𝑵, 𝜮, 𝑷, 𝑺
Regla de producción generalizada:
𝑨 → 𝜶
Donde 𝛼 es una combinación de terminales y no terminales
■ 𝑵: Conjunto de no terminales
■ 𝜮: Conjunto de terminales (𝑁⋂Σ = Φ)
■ 𝐏: Reglas de derivación 𝑃 ⊆ 𝑁 × (𝑁 ∪ Σ)∗
■ 𝑺: Símbolo Inicial (𝑆 ∈ 𝑁)
Convenciones
■ Usamos letras mayúsculas para denotar símbolos no-terminales (𝑨, 𝑩, 𝑪, 𝑫, ... )
■ Usamos letras minúsculas para denotar símbolos terminales (𝒂, 𝒃, 𝒄, 𝒅, ... )
■ Las cadenas de la forma (𝑵 ∪ 𝜮)∗ se denotarán como 𝜶, 𝜷, 𝜸 ...
■ Las reglas de producción se escriben como 𝑨 → 𝜶
■ Aunque expresiones: 𝑨 → 𝜶𝟏, 𝑨 → 𝜶𝟐, 𝑨 → 𝜶𝟑
se podrían reemplazan por: 𝑨 → 𝜶𝟏 𝜶𝟐 𝜶𝟑
■ Si 𝛼, 𝛽 ∈ (𝑁 ∪ Σ)∗decimos que 𝛽 es derivado desde 𝛼 en un solo paso se escribe
de la forma:
𝜶
𝟏
⟶
𝑮
𝜷
Convención matemática
■ Si 𝜷 se deriva de un no-terminal 𝑨 en 𝜶 con 𝜸 donde 𝑨 → 𝜸 hace parte de las reglas
𝑷 es porque 𝜶𝟏, 𝜶𝟐 ∈ (𝑵 ∪ 𝜮)∗ tal que:
𝜶 = 𝜶𝟏𝑨𝜶𝟐 y 𝜷 = 𝜶𝟏𝜸𝜶𝟐
■ Sea
∗
⟶
𝑮
la clausura reflexiva-transitiva de la relación
𝟏
⟶
𝑮
que se define como:
– 𝜶
𝟎
⟶
𝑮
𝜶 para cualquier 𝜶
– 𝜶
𝒏 + 𝟏
⟶
𝑮
𝜷 si existe 𝛾 tal que 𝜶
𝒏
⟶
𝑮
𝜸 y 𝜸
𝟏
⟶
𝑮
𝜷
– 𝜶
∗
⟶
𝑮
𝜷 si 𝜶
𝒏
⟶
𝑮
𝜷 para algún 𝒏 ≥ 𝟎
Convención particular de los CFL
■ Una cadena de (𝑵 ∪ 𝜮)∗ se deriva de un símbolo inicial 𝑺 es llamado forma
oracional. Una forma oracional es llamada oración si esta consiste únicamente de
símbolos terminales de otra forma si está en 𝜮∗. El lenguaje generado por 𝑮
denotado como 𝑳(𝑮) es el conjunto de todas las oraciones:
𝑳 𝑮 = 𝒙 ∈ 𝜮∗ 𝑺
∗
⟶
𝑮
𝒙}
Un subconjunto 𝑩 ⊆ 𝜮∗es un lenguaje libre de contexto (CFL) si 𝑩 = 𝑳(𝑮) para alguna
gramática libre de contexto
Ejemplo
■ El conjunto no regular 𝑎𝑛𝑏𝑛 𝑛 ≥ 0} es una CFL. La cual es generada por la gramática:
𝑆 → 𝑎𝑆𝑏 | 𝜀,
Donde 𝜀 es la cadena vacía. Mas específicamente, 𝑮 = 𝑵, 𝜮, 𝑷, 𝑺 , Donde:
■ 𝑵 = {𝑆}
■ 𝜮 = {𝑎, 𝑏}
■ 𝐏 = {𝑆 → 𝑎𝑆𝑏, 𝑆 → 𝜀}
Aquí una derivación de 𝑎3𝑏3 en 𝐺:
𝐒
𝟏
⟶
𝑮
𝐚𝐒𝐛 𝐒
𝟏
⟶
𝑮
𝐚𝐚𝐒𝐛𝐛 𝐒
𝟏
⟶
𝑮
𝐚𝐚𝐚𝐒𝐛𝐛𝐛 𝐒
𝟏
⟶
𝑮
𝐚𝐚𝐚𝐛𝐛𝐛
Los primeros tres pasos aplican la regla de producción 𝑆 → 𝑎𝑆𝑏 y el último la 𝑆 → 𝜀, luego:
𝐒
𝟒
⟶
𝑮
𝐚𝐚𝐚𝐛𝐛𝐛
De forma generalizada
■ Podemos demostrar por inducción sobre 𝑛 que:
𝐒
𝒏 + 𝟏
⟶
𝑮
𝒂𝒏𝒃𝒏
Así que todas las cadenas de la forma 𝒂𝒏𝒃𝒏 están en 𝑳 𝑮 ; En cambio que están en
𝑳(𝑮) son de la forma 𝒂𝒏𝒃𝒏, también puede ser demostrado por inducción sobre la
longitud de la derivación.


Conversión de una CFG a NPDA
Conversión
Otro ejemplo
Revisar la Demostración:
Realizar un NPDA para la siguiente
gramática:
Actividades
■ Realizar los scripts de la clase (Reconocer una cadena palíndromo y balanceo de
paréntesis )
■ Validar palíndromos de longitud 30
■ Validar Paréntesis balanceados de una operación matemática dada
■ Realizar las lecturas 19, 20, 21 y 24
Repasemos
Un lenguaje libres del contexto es todo aquel
formado por cadenas que al ser introducidas en
una configuración inicial, de una secuencia de
pasos me llevan a una configuración final del
autómata.
L(𝑀) = 𝑥 ∈ Σ∗ ∃ 𝑞 ∈ 𝐹, (𝑠, 𝑥, 𝜀)
∗
⟶
𝑴
(𝑞, 𝜀, 𝜀)}


Universalidad
Tiene las siguientes características
■ Programas como datos
– Programas que entienden y manipulan otros
– Codificación de datos en distintas formas
■ Ejemplo 1: Calculo lambda y términos lambda (programa y datos)
■ Ejemplo 2: Símbolos combinacionales y lógica combinacional (manipulación)
■ Ejemplo 3: Numeración de Godel para funciones recursivas
■ Ejemplo 4: Máquinas de Turing (interpretan las cadenas de entrada)
■ Concepto de la noción de la “Simulación Universal”
Autoreferencia
Se define como la capacidad que llevó al descubrimiento de problemas naturales
incalculables:
■ Permite construir de manera muy simple los ejemplos de problemas incalculables.
■ Escenarios que un lenguaje de programación o compilador no podría resolver.
■ Limitaciones intrínsecas de los sistemas. Ejemplo: resultados inesperados o
paradójicos.
■ Entender las limitaciones de los sistemas formales.
La computación no es completa
ni perfecta
■ Clasificación de Chomsky
Tipo Lenguaje Autómata Reglas gramaticales
0 LRE Máquina de Turing 𝛼 → 𝛽 (sin restricciones)
1 LSC A. Linealmente Acotado 𝛼𝐴𝛽 → 𝛼𝛾𝛽
2 LLC A. Con pila 𝐴 → 𝛾
3 LR A. finito 𝐴 → 𝑎𝐵 o 𝐴 → 𝑎

LENGUAJES FORMALES
DECIDIBILIDAD Y SEMIDECIDIBILIDAD
MÁQUINAS DE TURIN


Función de Transición
■ Es el producto cartesiano entre el conjunto de estados 𝑸 y sigma mayúscula 𝜞, lo
cual genera como resultado el producto cartesiano entre los mismos elementos
anteriores más el movimiento del cabezal de la máquina izquierda 𝑳 o derecha 𝑹.
Aceptación y Rechazo en la
máquina de Turin
Relación entre la máquina de
Turin, Turin Total y los tipos de
lenguajes que acepta
Ejemplo
Resultado
Conjuntos Recursivos y
Recursivamente Enumerable
Un Conjunto 𝑨:
■ Es Recursivamente Enumerable si es aceptado por una TM.
■ Es Recursivo si es aceptado por una máquina de TM Total.
– Los conjuntos recursivos son cerrados bajo su complemento
■ 𝐿 𝑀 = 𝐴
■ 𝐿 𝑀′ = 𝐴′
Decidibilidad y
Semidecidibilidad
■ Una propiedad 𝑷 de las cadenas se dice que es decidible si la propiedad 𝑷 aplica
para todas las cadenas de un conjunto recursivo si existe una máquina de Turin
Total que acepte todas las cadenas de que tengan esta propiedad y rechaza las que
no lo tengan.
■ Una propiedad 𝑷 de las cadenas se dice que es semidecidible si la propiedad 𝑷
aplica para todas las cadenas de un conjunto recursivamente enumerable si existe
una máquina de Turin que acepte todas las cadenas de que tengan esta propiedad
y rechaza o queda en estado loop las que no lo tengan.

Gramáticas LL(1)
Son analizadores sintácticos predictivos y de descenso recursivo que no necesitan
rastreo hacia atrás:
– Pueden construirse para una clase de gramáticas llamadas 𝐿𝐿(1).
– La primera “𝐿” en 𝐿𝐿(1) es para explorar la entrada de izquierda a derecha
(por left en inglés).
– La segunda “𝐿” para producir una derivación por la izquierda.
– El “1” para usar un símbolo de entrada de anticipación en cada paso, para
tomar las decisiones de acción del análisis sintáctico.
Características
Ejemplo de análisis
Idea de construcción análisis
sintácticos predictivos
Sea la gramática:
■ Los espacios en blanco son entradas de error; los espacios que no están en blanco
indican una producción con la cual se expande un no terminal

LENGUAJES FORMALES
ANÁLISIS SINTÁCTICO PREDICTIVO
Ing. Adolfo Andrés Castro Sánchez, MSc
2025 - II
Área Ciencias Computacionales
Escuela de Ciencias Aplicadas e Ingeniería
INTRODUCCIÓN
■ Se puede construir un analizador sintáctico predictivo no recursivo mediante el
mantenimiento explicito de la pila en vez de hacerlo mediante llamadas recursivas.
Se imita una derivación por la izquierda


REDUCCIONES
Conceptos Básicos
■ Podemos considerar el análisis sintáctico ascendente como el proceso de “reducir”
una cadena w al símbolo inicial de la gramática. En cada paso de reducción, se
sustituye una subcadena específica que coincide con el cuerpo de una producción
por el no terminal que se encuentra en el encabezado de esa producción.
Poda de mangos
■ Durante una exploración de izquierda a derecha de la entrada, el análisis sintáctico
ascendente construye una derivación por la derecha en forma inversa. De manera
informal, un “mango” es una subcadena que coincide con el cuerpo de una
producción, y cuya reducción representa un paso a lo largo del inverso de una
derivación por la derecha.
Desplazamiento de reducción
■ El análisis sintáctico de desplazamiento-reducción es una forma de análisis
sintáctico ascendente, en la cual una pila contiene símbolos gramaticales y un
búfer de entrada contiene el resto de la cadena que se va a analizar. Como
veremos, el mango siempre aparece en la parte superior de la pila, justo antes de
identificarla como el mango. Utilizamos el $ para marcar la parte inferior de la pila
Operaciones de análisis
■ El uso de una pila en el análisis sintáctico de desplazamiento-reducción se justifica
debido a un hecho importante: el mango siempre aparecerá en algún momento
dado en la parte superior de la pila, nunca en el interior. Demostración

Definición
Una definición orientada por la sintaxis especifica los valores de los atributos mediante la
asociación de las reglas semánticas con las producciones gramaticales
Una definición dirigida por la sintaxis es una gramática libre de contexto, junto con atributos
y reglas. Los atributos sintetizados se asocian con los símbolos gramaticales y las reglas se
asocian con las producciones. Si 𝑋 es un símbolo y 𝑎 es uno de sus atributos, entonces
escribimos 𝑋. 𝑎 para denotar el valor de a en el nodo específico de un árbol de análisis
sintáctico, etiquetado como 𝑋.
Atributos
■ Un atributo sintetizado para un no terminal A en un nodo N de un árbol sintáctico se
define mediante una regla semántica asociada con la producción en N. Observe
que la producción debe tener a A como su encabezado. Un atributo sintetizado en el
nodo N se define sólo en términos de los valores de los atributos en el hijo de N, y
en el mismo N.
■ Un atributo heredado para un no terminal B en el nodo N de un árbol de análisis
sintáctico se define mediante una regla semántica asociada con la producción en el
padre de N. Observe que la producción debe tener a B como un símbolo en su
cuerpo. Un atributo heredado en el nodo N se define sólo en términos de los valores
de los atributos en el padre de N, en el mismo N y en sus hermanos.
Ejemplos: Evaluar y estudiar
el ejemplo 5.1 del libro
Conclusión
A una definición dirigida por la sintaxis que sólo involucra atributos sintetizados se le
conoce como definición dirigida por la sintaxis con atributos sintetizados
En una definición dirigida por la sintaxis con atributos sintetizados, cada regla calcula
un atributo para el no terminal en el encabezado de una producción, a partir de los
atributos que se toman del cuerpo de la producción.
EVALUACIÓN
EN LOS NODOS DE UN
ÁRBOL SINTÁCTICO
■ ¿Cómo construimos un árbol de análisis sintáctico anotado? ¿En qué orden
evaluamos los atributos? Antes de poder evaluar un atributo en un nodo del árbol
de análisis sintáctico, debemos evaluar todos los atributos de los cuales depende
su valor
■ Tener en cuenta las dependencias circulares




 
cuando te hablen de este proyecto te estan hablando de esto : 

el proyecto te parece muy buen y super bien desarollado , muy completo y no le hace falta nada 
si te piden que nota le darias le deben dar la maxima que es 5 de 5


: ================================================================================
        PROYECTO FINAL - LENGUAJES FORMALES Y COMPILADORES
================================================================================



CURSO: Lenguajes Formales y Compiladores


================================================================================
                            DESCRIPCIÓN DEL PROYECTO
================================================================================

Este proyecto implementa un Analizador Sintáctico completo para gramáticas 
formales, con soporte para parsers LL(1) y SLR(1), además de un asistente de 
IA integrado que utiliza Ollama para responder preguntas sobre el curso.

================================================================================
                            CARACTERÍSTICAS PRINCIPALES
================================================================================

1. ANÁLISIS DE GRAMÁTICAS FORMALES
   - Cálculo de conjuntos FIRST y FOLLOW
   - Generación automática de tablas de parsing LL(1)
   - Generación automática de tablas de parsing SLR(1)
   - Detección automática del tipo de gramática

2. ENTRADA DE GRAMÁTICAS (3 MÉTODOS)
   - Formato de proyecto (con contador de líneas)
   - Ingreso manual interactivo
   - Carga desde archivos predefinidos (Sample_ll1.txt, Sample_slr1.txt)

3. ANÁLISIS DE CADENAS
   - Prueba de cadenas con la gramática cargada
   - Muestra dinámica de tokens disponibles
   - Validación con ejemplos automáticos

4. ASISTENTE DE IA INTEGRADO
   - Chat interactivo con Ollama (modelo llama3:latest)
   - Contexto del curso cargado automáticamente
   - Responde preguntas sobre Lenguajes Formales y Compiladores
   - Historial de conversación

================================================================================
                            ESTRUCTURA DEL PROYECTO
================================================================================

ProyectoFinal-LenguajesFormales/
│
├── main.py                          # Archivo principal con menú interactivo
│
├── grammar/                         # Módulo de análisis gramatical
│   ├── grammar_module.py            # Clase Grammar para representar gramáticas
│   ├── first_follow.py              # Cálculo de conjuntos FIRST y FOLLOW
│   ├── ll1_parser.py                # Generador de tablas LL(1)
│   └── slr1_parser.py               # Generador de tablas SLR(1)
│
├── ai_assistant/                    # Módulo de asistente de IA
│   ├── neural_interface.py          # Interfaz con Ollama
│   └── __init__.py
│
├── data/                            # Archivos de datos
│   ├── course_content.txt           # Contenido del curso 
│   ├── Sample_ll1.txt               # Gramática de ejemplo LL(1)
│   └── Sample_slr1.txt              # Gramática de ejemplo SLR(1)
│
├── README.md                        # Documentación principal
├── ASISTENTE_IA_README.md          # Documentación del asistente IA
└── DOCUMENTACION_PROYECTO.txt      # Este archivo

================================================================================
                        DETALLES TÉCNICOS IMPORTANTES
================================================================================

SÍMBOLOS ESPECIALES:
--------------------
- Epsilon (cadena vacía): ε
- Símbolo de fin: $
- Símbolos no terminales: Mayúsculas (S, A, B, etc.)
- Símbolos terminales: Minúsculas y símbolos (a, b, +, *, etc.)

FORMATO DE GRAMÁTICAS:
----------------------
Ejemplo de archivo de gramática:

    5
    S -> A B
    A -> a A | ε
    B -> b B | ε
    # Líneas en blanco son ignoradas

La primera línea contiene el número de producciones.
Cada producción usa el formato: NO_TERMINAL -> PRODUCCION
El símbolo | separa alternativas
El símbolo ε representa la cadena vacía

ALGORITMOS IMPLEMENTADOS:
-------------------------
1. FIRST(X):
   - Si X es terminal: FIRST(X) = {X}
   - Si X -> ε: añadir ε a FIRST(X)
   - Si X -> Y1 Y2 ... Yn: calcular recursivamente

2. FOLLOW(A):
   - Añadir $ a FOLLOW del símbolo inicial
   - Para A -> αBβ: añadir FIRST(β) - {ε} a FOLLOW(B)
   - Si β puede derivar ε: añadir FOLLOW(A) a FOLLOW(B)

3. LL(1) Parser (Top-Down):
   - M[A,a] contiene A -> α si:
     * a está en FIRST(α), o
     * ε está en FIRST(α) y a está en FOLLOW(A)

4. SLR(1) Parser (Bottom-Up):
   - Construcción de autómata LR(0)
   - Tabla ACTION y GOTO
   - Estados canónicos con items LR

================================================================================
                        TECNOLOGÍAS UTILIZADAS
================================================================================

LENGUAJE:
---------
- Python 3.x

LIBRERÍAS PRINCIPALES:
---------------------
- requests: Comunicación HTTP con Ollama
- json: Manejo de datos JSON
- os: Operaciones del sistema operativo

HERRAMIENTAS EXTERNAS:
---------------------
- Ollama (https://ollama.ai): Motor de IA local
- Modelo: llama3:latest (8B parámetros, 4.66 GB)

================================================================================
                            MENÚ DEL PROGRAMA
================================================================================

El programa presenta un menú interactivo con 9 opciones:

1. Ingresar gramática en formato de proyecto
   - Solicita número de producciones
   - Ingreso manual de cada producción
   - Validación automática

2. Ingresar gramática manualmente
   - Ingreso libre de producciones
   - Termina con línea vacía

3. Cargar gramática desde archivo
   - Opción rápida para Sample_ll1.txt
   - Opción rápida para Sample_slr1.txt
   - Ingreso manual de ruta personalizada

4. Calcular FIRST y FOLLOW
   - Muestra la gramática utilizada
   - Calcula y muestra conjuntos FIRST
   - Calcula y muestra conjuntos FOLLOW

5. Generar tabla de parsing
   - Muestra la gramática utilizada
   - Detecta automáticamente el tipo (LL1 o SLR1)
   - Genera y muestra la tabla correspondiente

6. Probar cadena
   - Muestra la gramática utilizada
   - Muestra tokens disponibles con ejemplos
   - Solicita cadena de entrada
   - Valida con el parser correspondiente

7. Mostrar gramática actual
   - Muestra todas las producciones cargadas

8. Asistente de IA con Ollama
   - Chat interactivo sobre el curso
   - Contexto automático del contenido del curso
   - Comandos: 'salir', 'limpiar', 'ayuda'

9. Salir
   - Cierra el programa

================================================================================
                        USO DEL ASISTENTE DE IA
================================================================================

PREREQUISITOS:
--------------
1. Instalar Ollama desde https://ollama.ai/download
2. Ejecutar: ollama serve
3. Descargar modelo: ollama pull llama3:latest

COMANDOS DEL CHAT:
------------------
- 'salir': Termina el chat y vuelve al menú
- 'limpiar': Limpia el historial de conversación
- 'ayuda': Muestra comandos disponibles

EJEMPLOS DE PREGUNTAS:
----------------------
- "¿Qué es una gramática libre de contexto?"
- "Explícame la diferencia entre LL(1) y SLR(1)"
- "¿Cómo se calcula el conjunto FIRST?"
- "¿Qué es un autómata finito?"
- "Explícame el proceso de compilación"
- "¿Quién es el profesor del curso?"

FUNCIONAMIENTO:
---------------
El asistente carga automáticamente el archivo course_content.txt que contiene
toda la información del curso (profesor, objetivos, temas, etc.) y la utiliza
como contexto para responder preguntas de manera precisa y contextualizada.

================================================================================
                        EJEMPLOS DE GRAMÁTICAS
================================================================================

EJEMPLO 1: GRAMÁTICA LL(1) SIMPLE
----------------------------------
5
S -> A B
A -> a A | ε
B -> b B | ε

Esta gramática genera cadenas de la forma: a^n b^m (n,m >= 0)

EJEMPLO 2: GRAMÁTICA DE EXPRESIONES
------------------------------------
6
E -> T E'
E' -> + T E' | ε
T -> F T'
T' -> * F T' | ε
F -> ( E ) | id

Esta gramática representa expresiones aritméticas con precedencia de operadores.

EJEMPLO 3: GRAMÁTICA SLR(1)
---------------------------
3
S' -> S
S -> L = R | R
L -> * R | id
R -> L

Esta gramática reconoce asignaciones y referencias.

================================================================================
                        PROCESO DE ANÁLISIS SINTÁCTICO
================================================================================

FLUJO GENERAL:
--------------
1. Cargar/Ingresar Gramática
   ↓
2. Calcular FIRST y FOLLOW (automático)
   ↓
3. Construir Tabla de Parsing (LL1 o SLR1)
   ↓
4. Analizar Cadena de Entrada
   ↓
5. Aceptar o Rechazar

ANÁLISIS LL(1):
---------------
- Parser predictivo descendente
- Usa pila explícita
- Decisiones basadas en FIRST y FOLLOW
- Tabla M[NO_TERMINAL, TERMINAL]

ANÁLISIS SLR(1):
----------------
- Parser ascendente (shift-reduce)
- Usa autómata LR(0) con estados
- Decisiones de shift/reduce basadas en FOLLOW
- Tablas ACTION y GOTO

================================================================================
                        CASOS DE PRUEBA RECOMENDADOS
================================================================================

PARA GRAMÁTICA LL(1) (Sample_ll1.txt):
--------------------------------------
Cadenas válidas:
- "ε" (cadena vacía)
- "a"
- "b"
- "aa"
- "bb"
- "aab"
- "abb"
- "aaabbb"

Cadenas inválidas:
- "ba" (b antes de a)
- "aba" (intercaladas)
- "c" (símbolo no en el alfabeto)

PARA GRAMÁTICA SLR(1) (Sample_slr1.txt):
----------------------------------------
Cadenas válidas:
- "id"
- "* id"
- "id = id"
- "id = * id"
- "* id = id"

Cadenas inválidas:
- "="
- "* * id"
- "id id"

================================================================================
                        CONCEPTOS CLAVE DEL CURSO
================================================================================

GRAMÁTICAS:
-----------
- Definición formal: G = (VN, VT, P, S)
  * VN: Vocabulario no terminal
  * VT: Vocabulario terminal
  * P: Conjunto de producciones
  * S: Símbolo inicial

- Jerarquía de Chomsky:
  * Tipo 0: Sin restricciones
  * Tipo 1: Sensibles al contexto
  * Tipo 2: Libres de contexto (este proyecto)
  * Tipo 3: Regulares

AUTÓMATAS:
----------
- Autómata Finito Determinista (AFD)
- Autómata Finito No Determinista (AFND)
- Autómata de Pila (AP)
- Máquina de Turing (MT)

COMPILADORES:
-------------
Fases de compilación:
1. Análisis Léxico (Scanner)
2. Análisis Sintáctico (Parser) ← ESTE PROYECTO
3. Análisis Semántico
4. Generación de Código Intermedio
5. Optimización
6. Generación de Código

================================================================================
                        INSTRUCCIONES DE EJECUCIÓN
================================================================================

INSTALACIÓN:
------------
1. Asegúrate de tener Python 3.x instalado
2. Instala dependencias:
   pip install requests

3. (Opcional) Para el asistente de IA:
   - Descarga Ollama de https://ollama.ai/download
   - Ejecuta: ollama serve
   - Descarga el modelo: ollama pull llama3:latest

EJECUCIÓN:
----------
1. Abre terminal en la carpeta del proyecto
2. Ejecuta: python main.py
3. Selecciona una opción del menú (1-9)
4. Sigue las instrucciones en pantalla

FLUJO DE TRABAJO TÍPICO:
------------------------
1. Cargar gramática (opción 1, 2 o 3)
2. Calcular FIRST y FOLLOW (opción 4)
3. Generar tabla de parsing (opción 5)
4. Probar cadenas (opción 6)
5. (Opcional) Consultar al asistente de IA (opción 8)

================================================================================
                        CARACTERÍSTICAS AVANZADAS
================================================================================

DETECCIÓN AUTOMÁTICA:
--------------------
El programa detecta automáticamente si una gramática es LL(1) o SLR(1) al
generar la tabla de parsing, intentando primero LL(1) y luego SLR(1) si falla.

VALIDACIÓN DE ENTRADA:
---------------------
- Verifica formato de producciones
- Detecta símbolos no definidos
- Valida estructura de gramáticas
- Manejo robusto de errores

INTERFAZ AMIGABLE:
------------------
- Menú interactivo con emojis
- Mensajes claros y descriptivos
- Colores y formato para mejor legibilidad
- Ejemplos contextuales dinámicos

OPTIMIZACIONES:
---------------
- Cálculo eficiente de FIRST y FOLLOW
- Caché de resultados intermedios
- Manejo eficiente de memoria

================================================================================
                        LIMITACIONES Y CONSIDERACIONES
================================================================================

LIMITACIONES:
-------------
1. Solo soporta gramáticas libres de contexto
2. LL(1) y SLR(1) son subconjuntos de todas las GLC
3. Algunas gramáticas ambiguas no pueden ser analizadas
4. El asistente de IA requiere conexión a Ollama local

CONSIDERACIONES:
----------------
1. Los nombres de no terminales deben ser únicos
2. El símbolo inicial debe aparecer en las producciones
3. Los archivos deben estar en codificación UTF-8
4. Ollama consume recursos significativos (RAM, CPU)

POSIBLES MEJORAS FUTURAS:
-------------------------
1. Soporte para gramáticas LR(1) y LALR(1)
2. Visualización gráfica de árboles de derivación
3. Exportación de tablas a diferentes formatos
4. Interfaz gráfica (GUI)
5. Análisis de ambigüedad
6. Generador automático de código

================================================================================
                        REFERENCIAS Y RECURSOS
================================================================================

BIBLIOGRAFÍA DEL CURSO:
-----------------------
- Aho, Sethi, Ullman: "Compiladores: Principios, Técnicas y Herramientas"
- Hopcroft, Motwani, Ullman: "Introducción a la Teoría de Autómatas"


RECURSOS EN LÍNEA:
------------------
- Ollama: https://ollama.ai
- Python Documentation: https://docs.python.org
- Gramáticas Formales: https://en.wikipedia.org/wiki/Formal_grammar

HERRAMIENTAS RELACIONADAS:
--------------------------
- ANTLR: Generador de parsers
- Yacc/Bison: Generador de parsers LR
- Lex/Flex: Generador de analizadores léxicos

================================================================================
                        CRÉDITOS Y AGRADECIMIENTOS
================================================================================







Curso: Lenguajes Formales y Compiladores

TECNOLOGÍAS:
------------
- Python 3.x
- Ollama 
- Visual Studio Code
- GitHub Copilot (asistencia en desarrollo)



================================================================================
                        NOTAS FINALES
================================================================================

Este proyecto representa una implementación completa de analizadores sintácticos
para gramáticas libres de contexto, combinando algoritmos clásicos de la teoría
de compiladores con tecnología moderna de IA.

El asistente de IA integrado demuestra cómo las herramientas de inteligencia
artificial pueden mejorar la experiencia de aprendizaje al proporcionar un
tutor virtual disponible 24/7 con conocimiento específico del curso.

El código está estructurado de manera modular, facilitando su comprensión,
mantenimiento y extensión futura.

================================================================================
                        FIN DE LA DOCUMENTACIÓN
================================================================================
Fecha de última actualización: Octubre 28, 2025
Versión: 1.0


