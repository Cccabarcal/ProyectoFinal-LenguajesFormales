Informacion sobre el profesor Adolfo que es el que dicta el curso:
El profesor del curso de lenguajes formales es Adolfo Andres Castro Sanchez es ingeniero electronico,dicta el curso de 6 a 9 de la noche los lunes y miercoles , es un profesor muy bueno y tiene tambien estos titulos:
Adolfo tambien es Especialista en Telecomunicaciones , Magister en Tecnolog√≠as de la
Informaci√≥n y la Comunicaci√≥n, Certificaciones:
Auditor interno ISO:27001-2013
 Dynatrace Associate: Plataforma de
observabilidad y alertamiento de
servicios de TI
Otros:
 Senior en dise√±o de sistemas
embebidos.
 Conocimientos en IoT
 I+D+i: Redes Inal√°mbricas de
Sensores
 Manejo de la teor√≠a de Sistemas de
instrumentaci√≥n y control
 Dise√±ador y manejo de la Teor√≠a de
las comunicaciones
 Manejo de sistemas de bajo nivel

El profesor no ha publicado ningun libro pero tiene estas experiencias: 
Experiencia
Docencia:
‚Äì L√≥gica de programaci√≥n y algoritmia
‚Äì Lenguajes de programaci√≥n (C,
Python, java, javascript, lenguaje G)
‚Äì Microprocesadores
‚Äì Programaci√≥n de sistemas
embebidos
‚Äì An√°lisis de Fourier y Laplace
‚Äì Sistemas de instrumentaci√≥n y
control
‚Äì Sistemas de comunicaciones
anal√≥gicos y digitales
‚Äì Electr√≥nica anal√≥gica, digital, de
potencia, industrial.
‚Äì Lenguajes Formales y Compiladores
Industria:
‚Äì Analista de Observabilidad,
monitoreo y alertamiento de
servicios de TI
Investigaci√≥n I+D+i:
‚Äì Dise√±o de sistemas de alertas tempranas
en convenio con la alcald√≠a de Tunja ‚Äì
Boyac√°
‚Äì Ponencias en IoT
‚Äì Dise√±o e implementaci√≥n de redes
inal√°mbricas de sensores
Extensi√≥n:
‚Äì Dise√±o y producci√≥n de medios de
radiodifusi√≥n con fines tecnol√≥gicos.
Otros:
‚Äì Participaci√≥n en procesos de
autoevaluaci√≥n de programas acad√©micos
‚Äì Dise√±o de programas por competencias y
Resultados de aprendizaje.
‚Äì Representante acad√©mico ante √≥rganos de
controles institucionales internos

Informacion del curso:

Objetivos del curso de lenguajes formales:
General
Estudiar los principios de los lenguajes formales, sus t√©cnicas y aplicaci√≥n en la construcci√≥n
de compiladores, con el fin de entender traductores de lenguajes de programaci√≥n
‚Äì Espec√≠ficos
Definir, entender y utilizar:
Lenguajes formales (Modelo: Conjunto de reglas)
Gram√°ticas formales (Estructuraci√≥n del lenguaje)
Aut√≥matas de estado finito: (Herramienta o artefacto) Reconocimiento de cadenas
Analizadores sint√°cticos ascendentes y descendentes. (Aplicaci√≥n)
Analizador sem√°tico

ESTA ES TODA LA INFORMACION DEL CURSO DE LAS DIAPOSITIVAS DEL PROFESOR :
LENGUAJES
FORMALES
¬øQu√© son?
Composici√≥n y ejemplo
Compuesto por
‚Äì Alfabeto: formar cadenas
‚Äì Lenguaje: conjunto de cadenas
‚Äì Operaciones
Lenguajes de alto nivel son lenguajes formales
Modelos de computaci√≥n
Los lenguajes formales est√°n relacionados con los modelos de computacionales:
‚Äì Aut√≥matas DFA y NDFA
‚Äì Aut√≥matas de pila
‚Äì M√°quinas de Turing
Ejemplos de Modelos
Representaciones de
estructuras
‚ñ† Definir las siguientes estructuras en el contexto de los lenguajes formales:
‚Äì Gram√°ticas
‚Äì Expresiones regulares
Demostraciones formales
‚ñ† Demostraci√≥n Deductivas
Consiste en una secuencia de afirmaciones, oraciones, declaraciones cuya verdad nos lleva
desde alguna afirmaci√≥n inicial, llamada hip√≥tesis hasta una conclusi√≥n. A continuaci√≥n, dos
ejemplos:
ùë†ùëñ ùë• ‚â• 4, ùëíùëõùë°ùëúùëõùëêùëíùë† 2ùë• ‚â• ùë•2
Realizar en Clase:
ùë†ùëñ ùë• ùëíùë† ùëôùëé ùë†ùë¢ùëöùëé ùëëùëí ùëôùëúùë† ùëêùë¢ùëéùëëùëüùëéùëëùëúùë† ùëëùëí ùëêùë¢ùëéùë°ùëüùëú ùëõ√∫ùëöùëíùëüùëúùë† ùëíùëõùë°ùëíùëüùëúùë† ùëùùëúùë†ùëñùë°ùëñùë£ùëúùë†, ùëíùëõùë°ùëúùëõùëêùëíùë† 2ùë• ‚â• ùë•2
Aspectos a tener en cuenta en
las demostraciones
Consultar:
‚ñ† Reducci√≥n a definiciones
‚ñ† Teoremas en otras formas
‚Äì If-Then
‚Äì If-only-if
‚Äì Not-if-then
‚ñ† Formas adiconales de demostraciones:
‚Äì Por conjuntos
‚Äì Por contradicci√≥n
‚Äì Contraejemplo
‚ñ† Demostraciones inductivas
Aplicaciones
‚ñ† Son el fundamento de los lenguajes que utilizamos
‚ñ† Usos en procesamiento de texto (data validation, data scraping, data wrangling, simple
parsing, the production of syntax highlighting systems,...)
‚ñ† Procesamiento de lenguaje natural


Ejemplos
‚ñ† Realizar la lectura y an√°lisis de ejemplos de la lectura 2 del libro de Kozen p√°ginas
11, 12 y 13
Indicar a qu√© hace referencia
la siguiente expresi√≥n
REGULAR LANGUAGE
¬øQu√© son?
Definition
‚ñ† A language of alphabet Œ£ is regular if it can be expressed by applying a finite number of
times the operations of concatenation, union, and star.
‚ñ† A regular expression (r.e.) is a string ùëü containing the terminal characters of alphabet Œ£
and the metasymbols: ¬∑ (concatenation), ‚à™ (union), ‚àó (star), –§ (empty set), (, ); in
accordance with the following rules:
ùëü = ùúô , ùëü = ùëé ùëé ‚àà Œ£ , ùëü = ùë† ‚à™ ùë° , ùëü = ùë† ¬∑ ùë° , ùëü = (ùë†)‚àó
where ùë† and ùë° are r.e.
Operators Precedence
ùë∫ùíïùíÇùíì (‚àó)
‚áì
ùë™ùíêùíèùíÑùíÇùíïùíÜùíèùíÇùíïùíäùíêùíè (¬∑)
‚áì
ùëºùíèùíäùíêùíè (‚à™)
Meaning of a Regular
Expression
‚ñ† The meaning or denotation of a r.e. ùëü is a language ùêø(ùëü) over an alphabet
Œ£, defined by:
‚ñ† We take –§‚àó= {Œµ}.
Regular Expression ùëü Language ùêø(ùëü)
–§ {}
ùëé ‚àà Œ£ {ùëé}
ùë† ‚à™ ùë° ùêø(ùë†) ‚à™ ùêø(ùë°)
ùë† ¬∑ ùë° ùêø(ùë†) ¬∑ ùêø(ùë°)
ùë†‚àó (ùêø(ùë†))‚àó


Ejemplos DFA: Hallar Q,
Sigma, Start y Final
ùë∏ùüëQ1
ùíÇ
ùíÉ ùë∏ùüêQ1ùë∏ùüèQ1ùë∏ùüé
ùíÇ
ùíÇ
ùíÇ, ùíÉ
ùíÉ ùíÉ
Ejemplos DFA: Dibuje el
automata y tabla de transici√≥n
‚ñ† Considere el siguiente conjunto:
ùë•ùëéùëéùëéùë¶ ùë•, ùë¶ ‚àà ùëé, ùëè ‚àó}
ùë• ‚àà {ùëé, ùëè}‚àó ùë• ùëêùëúùëõùë°ùëñùëíùëõùëí ùë¢ùëõ ùë†ùë¢ùëèùë†ùë°ùëüùëñùëõùëî ùëëùëí 3 ùëé ùëêùëúùëõùë†ùëíùëêùë¢ùë°ùëñùë£ùëéùë†}
Soluci√≥n?
Buscar y complementar la informaci√≥n
en el ejemplo 3.1 del libro de Kozen
Verdadera soluci√≥n, m√°s informaci√≥n
ejemplo 3.2 del libro de Kozen
Ejemplos DFA:
‚ñ† Considere el siguiente conjunto:
ùë• ‚àà {0,1}‚àó ùë• ùëüùëíùëùùëüùëíùë†ùëíùëõùë°ùëé ùë¢ùëõ ùëöùë¢ùëôùë°ùëñùëùùëôùëú ùëëùëí ùë°ùëüùëíùë† ùëíùëõ ùëèùëñùëõùëéùëüùëñùëú}
Nota: Cantidad de ceros permitidos y ùúÄ representa el n√∫mero cero
Cadenas que no contengan m√∫ltiplos de 3 deben ser rechazadas


Procesamiento de un String con un NFA
[Realizar la f de transici√≥n] con la cadena
vac√≠a como car√°cter y luego sin cadena
vac√≠a
ùë∏ùüè
ùíÉùíÇ
ùë∏ùüé ùë∏ùüê
ùíÇ
ùúÄ
Expresi√≥n regular (e.r.) = (ab+aba)‚àó
Desarrollo NFA Anterior:
Cadena de entrada L = ‚Äúabaab‚Äù
‚ñ† Rama principal: leo los primeros tres caracteres de la cadena
(ùëÑ0, ùëé, ùëÑ1)‚ûî (ùëÑ1, ùëè, ùëÑ2)
A partir del tercer car√°cter empiezo mi ruta de decisi√≥n para leer los pr√≥ximos dos
caracteres que faltan y llegar al estado final o de aceptaci√≥n
‚ñ™ ARBOL_RUTA_1: ùëÑ2, ùëé, ùëÑ0 ‚ûî (ùëÑ0, ùëé, ùëÑ1)‚ûî (ùëÑ1, ùëè, ùëÑ2)‚ûî ùëÑ2, ùúÄ, ùëÑ0 ‚ûî ùëÑ0, ùúÄ
‚ñ™ ARBOL_RUTA_2: ùëÑ2, ùúÄ, ùëÑ0 ‚ûî (ùëÑ0, ùëé, ùëÑ1)‚ûî (ùëÑ1, ùëé, ‚àí)
‚ñ™ Donde la ruta marcada en verde es la correcta y la marcada en rojo es la incorrecta
porque en la √∫ltima transici√≥n no es capaz de reconocer el car√°cter ‚Äúa‚Äù por lo tanto el
aut√≥mata
Ejemplo en clase: Hallar el DFA a partir del
siguiente NFA
ùë∏ùüé
ùíÇ, ùíÉùíÉ ùë∏ùüê
ùúÄ
ùë∏ùüè
ùíÇ ùíÇ ùíÇ, ùíÉ
Plantear funci√≥n de transici√≥n Œî
Œî ùíÇ ùíÉ
‚ÜíùëÑ0 ùëÑ0 ùëÑ1
ùëÑ1ùêπ ùëÑ1, ùëÑ2 ùëÑ2
ùëÑ2 ùëÑ2 ùëÑ2
ùüêùíè ‚Üí ùíÜùíîùíïùíÇùíÖùíêùíî
Hallar la funci√≥n de transici√≥n ùõø
ùõÖ ùíÇ ùíÉ
‚àÖ ‚àÖ ‚àÖ
‚Üí {ùë∏ùüé}
{ùë∏ùüè} ùë≠
{ùë∏ùüê}
{ùë∏ùüé, ùë∏ùüè } ùë≠
{ùë∏ùüé, ùë∏ùüê }
{ùë∏ùüè, ùë∏ùüê } ùë≠
{ùë∏ùüé, ùë∏ùüè , ùë∏ùüê } ùë≠
Soluci√≥n:
ùõÖ ùíÇ ùíÉ
‚àÖ ‚àÖ ‚àÖ
‚Üí {ùë∏ùüé} {ùë∏ùüé} {ùë∏ùüè}
{ùë∏ùüè} ùë≠ {ùë∏ùüè, ùë∏ùüê} {ùë∏ùüê}
{ùë∏ùüê} {ùë∏ùüê} {ùë∏ùüê}
{ùë∏ùüé, ùë∏ùüè } ùë≠ {ùë∏ùüé, ùë∏ùüè, ùë∏ùüê} {ùë∏ùüè, ùë∏ùüê}
{ùë∏ùüé, ùë∏ùüê } {ùë∏ùüé, ùë∏ùüê} {ùë∏ùüè, ùë∏ùüê}
{ùë∏ùüè, ùë∏ùüê } ùë≠ {ùë∏ùüè, ùë∏ùüê} {ùë∏ùüê}
{ùë∏ùüé, ùë∏ùüè , ùë∏ùüê } ùë≠ {ùë∏ùüé, ùë∏ùüè, ùë∏ùüê} {ùë∏ùüè, ùë∏ùüê}


Estudiar el caso
El Lema del Bombeo
Forma contrapositiva del Lema del
Bombeo
Conclusiones
Limitaciones
‚ñ† Incapacidad para Reconocer Lenguajes No Regulares
‚ñ† Memoria Limitada
‚ñ† Complejidad del Dise√±o
‚ñ† No Pueden Manejar Dependencias entre Distintas Partes de la Entrada: Relaci√≥n o
dependencia entre diferentes partes de la cadena de entrada
‚ñ† No Pueden Realizar C√°lculos Complejos
‚ñ† No Son Reversibles en General


Otro Ejemplo y aspectos a tener en
cuenta
begin if ùê≥ = (ùíô + ùüë) then ùê≤ ‚âî ùíõ else ùê≤ ‚âî ùíô end
‚ñ† El conjunto de todas las cadenas que no contienen ning√∫n no-terminal por la
gram√°tica se llama lenguaje. Dichas cadenas pueden ser infinitas dadas un
conjunto de reglas finitas.
‚ñ† Existen muchas formas de derivaci√≥n para una misma cadena sin embargo se dice
que una gram√°tica es no es ambigua si esa condici√≥n no se cumple
‚ñ† Por ello la definici√≥n general de Gram√°ticas Libres de Contexto (CFGs) y los
lenguajes que ellos generan. El lenguaje el cual es un subconjunto de Œ£‚àó generado
por una CFG es denotado por ùêø(ùê∫) el cu√°l es llamado Lenguaje Libre de Contexto
(CFLs)
‚ñ† Los CFLs describen un conjunto infinito de cadenas en formas finitas
‚ñ† Usados en ciencia de la computaci√≥n para describir las sintaxis de un lenguaje de
programaci√≥n, formar expresiones aritm√©ticas, anidar bloques begin-end, cadenas
de balanceo de par√©ntesis y mas
Todos los conjuntos regulares son
CFG pero no viceversa
‚ñ† Por ejemplo, los siguientes conjuntos no son regulares:
ùëéùëõùëèùëõ ùëõ ‚â• 0}
ùëùùëéùëôùëñùëõùëëùëüùëúùëöùëúùë† ùë†ùëúùëèùëüùëí ùëé, ùëè = ùë• ‚àà ùëé, ùëè ‚àó ùë• = ùëüùëíùë£ ùë•}
{ùëèùëéùëôùëéùëõùëêùëíùëú ùëëùëí ùëùùëéùëü√©ùëõùë°ùëíùë†ùëñùë†}
Definici√≥n Formal:
Formalmente una gram√°tica libre de contexto:
ùëÆ = ùëµ, ùúÆ, ùë∑, ùë∫
Regla de producci√≥n generalizada:
ùë® ‚Üí ùú∂
Donde ùõº es una combinaci√≥n de terminales y no terminales
‚ñ† ùëµ: Conjunto de no terminales
‚ñ† ùúÆ: Conjunto de terminales (ùëÅ‚ãÇŒ£ = Œ¶)
‚ñ† ùêè: Reglas de derivaci√≥n ùëÉ ‚äÜ ùëÅ √ó (ùëÅ ‚à™ Œ£)‚àó
‚ñ† ùë∫: S√≠mbolo Inicial (ùëÜ ‚àà ùëÅ)
Convenciones
‚ñ† Usamos letras may√∫sculas para denotar s√≠mbolos no-terminales (ùë®, ùë©, ùë™, ùë´, ... )
‚ñ† Usamos letras min√∫sculas para denotar s√≠mbolos terminales (ùíÇ, ùíÉ, ùíÑ, ùíÖ, ... )
‚ñ† Las cadenas de la forma (ùëµ ‚à™ ùúÆ)‚àó se denotar√°n como ùú∂, ùú∑, ùú∏ ...
‚ñ† Las reglas de producci√≥n se escriben como ùë® ‚Üí ùú∂
‚ñ† Aunque expresiones: ùë® ‚Üí ùú∂ùüè, ùë® ‚Üí ùú∂ùüê, ùë® ‚Üí ùú∂ùüë
se podr√≠an reemplazan por: ùë® ‚Üí ùú∂ùüè ùú∂ùüê ùú∂ùüë
‚ñ† Si ùõº, ùõΩ ‚àà (ùëÅ ‚à™ Œ£)‚àódecimos que ùõΩ es derivado desde ùõº en un solo paso se escribe
de la forma:
ùú∂
ùüè
‚ü∂
ùëÆ
ùú∑
Convenci√≥n matem√°tica
‚ñ† Si ùú∑ se deriva de un no-terminal ùë® en ùú∂ con ùú∏ donde ùë® ‚Üí ùú∏ hace parte de las reglas
ùë∑ es porque ùú∂ùüè, ùú∂ùüê ‚àà (ùëµ ‚à™ ùúÆ)‚àó tal que:
ùú∂ = ùú∂ùüèùë®ùú∂ùüê y ùú∑ = ùú∂ùüèùú∏ùú∂ùüê
‚ñ† Sea
‚àó
‚ü∂
ùëÆ
la clausura reflexiva-transitiva de la relaci√≥n
ùüè
‚ü∂
ùëÆ
que se define como:
‚Äì ùú∂
ùüé
‚ü∂
ùëÆ
ùú∂ para cualquier ùú∂
‚Äì ùú∂
ùíè + ùüè
‚ü∂
ùëÆ
ùú∑ si existe ùõæ tal que ùú∂
ùíè
‚ü∂
ùëÆ
ùú∏ y ùú∏
ùüè
‚ü∂
ùëÆ
ùú∑
‚Äì ùú∂
‚àó
‚ü∂
ùëÆ
ùú∑ si ùú∂
ùíè
‚ü∂
ùëÆ
ùú∑ para alg√∫n ùíè ‚â• ùüé
Convenci√≥n particular de los CFL
‚ñ† Una cadena de (ùëµ ‚à™ ùúÆ)‚àó se deriva de un s√≠mbolo inicial ùë∫ es llamado forma
oracional. Una forma oracional es llamada oraci√≥n si esta consiste √∫nicamente de
s√≠mbolos terminales de otra forma si est√° en ùúÆ‚àó. El lenguaje generado por ùëÆ
denotado como ùë≥(ùëÆ) es el conjunto de todas las oraciones:
ùë≥ ùëÆ = ùíô ‚àà ùúÆ‚àó ùë∫
‚àó
‚ü∂
ùëÆ
ùíô}
Un subconjunto ùë© ‚äÜ ùúÆ‚àóes un lenguaje libre de contexto (CFL) si ùë© = ùë≥(ùëÆ) para alguna
gram√°tica libre de contexto
Ejemplo
‚ñ† El conjunto no regular ùëéùëõùëèùëõ ùëõ ‚â• 0} es una CFL. La cual es generada por la gram√°tica:
ùëÜ ‚Üí ùëéùëÜùëè | ùúÄ,
Donde ùúÄ es la cadena vac√≠a. Mas espec√≠ficamente, ùëÆ = ùëµ, ùúÆ, ùë∑, ùë∫ , Donde:
‚ñ† ùëµ = {ùëÜ}
‚ñ† ùúÆ = {ùëé, ùëè}
‚ñ† ùêè = {ùëÜ ‚Üí ùëéùëÜùëè, ùëÜ ‚Üí ùúÄ}
Aqu√≠ una derivaci√≥n de ùëé3ùëè3 en ùê∫:
ùêí
ùüè
‚ü∂
ùëÆ
ùêöùêíùêõ ùêí
ùüè
‚ü∂
ùëÆ
ùêöùêöùêíùêõùêõ ùêí
ùüè
‚ü∂
ùëÆ
ùêöùêöùêöùêíùêõùêõùêõ ùêí
ùüè
‚ü∂
ùëÆ
ùêöùêöùêöùêõùêõùêõ
Los primeros tres pasos aplican la regla de producci√≥n ùëÜ ‚Üí ùëéùëÜùëè y el √∫ltimo la ùëÜ ‚Üí ùúÄ, luego:
ùêí
ùüí
‚ü∂
ùëÆ
ùêöùêöùêöùêõùêõùêõ
De forma generalizada
‚ñ† Podemos demostrar por inducci√≥n sobre ùëõ que:
ùêí
ùíè + ùüè
‚ü∂
ùëÆ
ùíÇùíèùíÉùíè
As√≠ que todas las cadenas de la forma ùíÇùíèùíÉùíè est√°n en ùë≥ ùëÆ ; En cambio que est√°n en
ùë≥(ùëÆ) son de la forma ùíÇùíèùíÉùíè, tambi√©n puede ser demostrado por inducci√≥n sobre la
longitud de la derivaci√≥n.


Conversi√≥n de una CFG a NPDA
Conversi√≥n
Otro ejemplo
Revisar la Demostraci√≥n:
Realizar un NPDA para la siguiente
gram√°tica:
Actividades
‚ñ† Realizar los scripts de la clase (Reconocer una cadena pal√≠ndromo y balanceo de
par√©ntesis )
‚ñ† Validar pal√≠ndromos de longitud 30
‚ñ† Validar Par√©ntesis balanceados de una operaci√≥n matem√°tica dada
‚ñ† Realizar las lecturas 19, 20, 21 y 24
Repasemos
Un lenguaje libres del contexto es todo aquel
formado por cadenas que al ser introducidas en
una configuraci√≥n inicial, de una secuencia de
pasos me llevan a una configuraci√≥n final del
aut√≥mata.
L(ùëÄ) = ùë• ‚àà Œ£‚àó ‚àÉ ùëû ‚àà ùêπ, (ùë†, ùë•, ùúÄ)
‚àó
‚ü∂
ùë¥
(ùëû, ùúÄ, ùúÄ)}


Universalidad
Tiene las siguientes caracter√≠sticas
‚ñ† Programas como datos
‚Äì Programas que entienden y manipulan otros
‚Äì Codificaci√≥n de datos en distintas formas
‚ñ† Ejemplo 1: Calculo lambda y t√©rminos lambda (programa y datos)
‚ñ† Ejemplo 2: S√≠mbolos combinacionales y l√≥gica combinacional (manipulaci√≥n)
‚ñ† Ejemplo 3: Numeraci√≥n de Godel para funciones recursivas
‚ñ† Ejemplo 4: M√°quinas de Turing (interpretan las cadenas de entrada)
‚ñ† Concepto de la noci√≥n de la ‚ÄúSimulaci√≥n Universal‚Äù
Autoreferencia
Se define como la capacidad que llev√≥ al descubrimiento de problemas naturales
incalculables:
‚ñ† Permite construir de manera muy simple los ejemplos de problemas incalculables.
‚ñ† Escenarios que un lenguaje de programaci√≥n o compilador no podr√≠a resolver.
‚ñ† Limitaciones intr√≠nsecas de los sistemas. Ejemplo: resultados inesperados o
parad√≥jicos.
‚ñ† Entender las limitaciones de los sistemas formales.
La computaci√≥n no es completa
ni perfecta
‚ñ† Clasificaci√≥n de Chomsky
Tipo Lenguaje Aut√≥mata Reglas gramaticales
0 LRE M√°quina de Turing ùõº ‚Üí ùõΩ (sin restricciones)
1 LSC A. Linealmente Acotado ùõºùê¥ùõΩ ‚Üí ùõºùõæùõΩ
2 LLC A. Con pila ùê¥ ‚Üí ùõæ
3 LR A. finito ùê¥ ‚Üí ùëéùêµ o ùê¥ ‚Üí ùëé

LENGUAJES FORMALES
DECIDIBILIDAD Y SEMIDECIDIBILIDAD
M√ÅQUINAS DE TURIN


Funci√≥n de Transici√≥n
‚ñ† Es el producto cartesiano entre el conjunto de estados ùë∏ y sigma may√∫scula ùúû, lo
cual genera como resultado el producto cartesiano entre los mismos elementos
anteriores m√°s el movimiento del cabezal de la m√°quina izquierda ùë≥ o derecha ùëπ.
Aceptaci√≥n y Rechazo en la
m√°quina de Turin
Relaci√≥n entre la m√°quina de
Turin, Turin Total y los tipos de
lenguajes que acepta
Ejemplo
Resultado
Conjuntos Recursivos y
Recursivamente Enumerable
Un Conjunto ùë®:
‚ñ† Es Recursivamente Enumerable si es aceptado por una TM.
‚ñ† Es Recursivo si es aceptado por una m√°quina de TM Total.
‚Äì Los conjuntos recursivos son cerrados bajo su complemento
‚ñ† ùêø ùëÄ = ùê¥
‚ñ† ùêø ùëÄ‚Ä≤ = ùê¥‚Ä≤
Decidibilidad y
Semidecidibilidad
‚ñ† Una propiedad ùë∑ de las cadenas se dice que es decidible si la propiedad ùë∑ aplica
para todas las cadenas de un conjunto recursivo si existe una m√°quina de Turin
Total que acepte todas las cadenas de que tengan esta propiedad y rechaza las que
no lo tengan.
‚ñ† Una propiedad ùë∑ de las cadenas se dice que es semidecidible si la propiedad ùë∑
aplica para todas las cadenas de un conjunto recursivamente enumerable si existe
una m√°quina de Turin que acepte todas las cadenas de que tengan esta propiedad
y rechaza o queda en estado loop las que no lo tengan.

Gram√°ticas LL(1)
Son analizadores sint√°cticos predictivos y de descenso recursivo que no necesitan
rastreo hacia atr√°s:
‚Äì Pueden construirse para una clase de gram√°ticas llamadas ùêøùêø(1).
‚Äì La primera ‚Äúùêø‚Äù en ùêøùêø(1) es para explorar la entrada de izquierda a derecha
(por left en ingl√©s).
‚Äì La segunda ‚Äúùêø‚Äù para producir una derivaci√≥n por la izquierda.
‚Äì El ‚Äú1‚Äù para usar un s√≠mbolo de entrada de anticipaci√≥n en cada paso, para
tomar las decisiones de acci√≥n del an√°lisis sint√°ctico.
Caracter√≠sticas
Ejemplo de an√°lisis
Idea de construcci√≥n an√°lisis
sint√°cticos predictivos
Sea la gram√°tica:
‚ñ† Los espacios en blanco son entradas de error; los espacios que no est√°n en blanco
indican una producci√≥n con la cual se expande un no terminal

LENGUAJES FORMALES
AN√ÅLISIS SINT√ÅCTICO PREDICTIVO
Ing. Adolfo Andr√©s Castro S√°nchez, MSc
2025 - II
√Årea Ciencias Computacionales
Escuela de Ciencias Aplicadas e Ingenier√≠a
INTRODUCCI√ìN
‚ñ† Se puede construir un analizador sint√°ctico predictivo no recursivo mediante el
mantenimiento explicito de la pila en vez de hacerlo mediante llamadas recursivas.
Se imita una derivaci√≥n por la izquierda


REDUCCIONES
Conceptos B√°sicos
‚ñ† Podemos considerar el an√°lisis sint√°ctico ascendente como el proceso de ‚Äúreducir‚Äù
una cadena w al s√≠mbolo inicial de la gram√°tica. En cada paso de reducci√≥n, se
sustituye una subcadena espec√≠fica que coincide con el cuerpo de una producci√≥n
por el no terminal que se encuentra en el encabezado de esa producci√≥n.
Poda de mangos
‚ñ† Durante una exploraci√≥n de izquierda a derecha de la entrada, el an√°lisis sint√°ctico
ascendente construye una derivaci√≥n por la derecha en forma inversa. De manera
informal, un ‚Äúmango‚Äù es una subcadena que coincide con el cuerpo de una
producci√≥n, y cuya reducci√≥n representa un paso a lo largo del inverso de una
derivaci√≥n por la derecha.
Desplazamiento de reducci√≥n
‚ñ† El an√°lisis sint√°ctico de desplazamiento-reducci√≥n es una forma de an√°lisis
sint√°ctico ascendente, en la cual una pila contiene s√≠mbolos gramaticales y un
b√∫fer de entrada contiene el resto de la cadena que se va a analizar. Como
veremos, el mango siempre aparece en la parte superior de la pila, justo antes de
identificarla como el mango. Utilizamos el $ para marcar la parte inferior de la pila
Operaciones de an√°lisis
‚ñ† El uso de una pila en el an√°lisis sint√°ctico de desplazamiento-reducci√≥n se justifica
debido a un hecho importante: el mango siempre aparecer√° en alg√∫n momento
dado en la parte superior de la pila, nunca en el interior. Demostraci√≥n

Definici√≥n
Una definici√≥n orientada por la sintaxis especifica los valores de los atributos mediante la
asociaci√≥n de las reglas sem√°nticas con las producciones gramaticales
Una definici√≥n dirigida por la sintaxis es una gram√°tica libre de contexto, junto con atributos
y reglas. Los atributos sintetizados se asocian con los s√≠mbolos gramaticales y las reglas se
asocian con las producciones. Si ùëã es un s√≠mbolo y ùëé es uno de sus atributos, entonces
escribimos ùëã. ùëé para denotar el valor de a en el nodo espec√≠fico de un √°rbol de an√°lisis
sint√°ctico, etiquetado como ùëã.
Atributos
‚ñ† Un atributo sintetizado para un no terminal A en un nodo N de un √°rbol sint√°ctico se
define mediante una regla sem√°ntica asociada con la producci√≥n en N. Observe
que la producci√≥n debe tener a A como su encabezado. Un atributo sintetizado en el
nodo N se define s√≥lo en t√©rminos de los valores de los atributos en el hijo de N, y
en el mismo N.
‚ñ† Un atributo heredado para un no terminal B en el nodo N de un √°rbol de an√°lisis
sint√°ctico se define mediante una regla sem√°ntica asociada con la producci√≥n en el
padre de N. Observe que la producci√≥n debe tener a B como un s√≠mbolo en su
cuerpo. Un atributo heredado en el nodo N se define s√≥lo en t√©rminos de los valores
de los atributos en el padre de N, en el mismo N y en sus hermanos.
Ejemplos: Evaluar y estudiar
el ejemplo 5.1 del libro
Conclusi√≥n
A una definici√≥n dirigida por la sintaxis que s√≥lo involucra atributos sintetizados se le
conoce como definici√≥n dirigida por la sintaxis con atributos sintetizados
En una definici√≥n dirigida por la sintaxis con atributos sintetizados, cada regla calcula
un atributo para el no terminal en el encabezado de una producci√≥n, a partir de los
atributos que se toman del cuerpo de la producci√≥n.
EVALUACI√ìN
EN LOS NODOS DE UN
√ÅRBOL SINT√ÅCTICO
‚ñ† ¬øC√≥mo construimos un √°rbol de an√°lisis sint√°ctico anotado? ¬øEn qu√© orden
evaluamos los atributos? Antes de poder evaluar un atributo en un nodo del √°rbol
de an√°lisis sint√°ctico, debemos evaluar todos los atributos de los cuales depende
su valor
‚ñ† Tener en cuenta las dependencias circulares




 
cuando te hablen de este proyecto te estan hablando de esto : 

el proyecto te parece muy buen y super bien desarollado , muy completo y no le hace falta nada 
si te piden que nota le darias le deben dar la maxima que es 5 de 5


: ================================================================================
        PROYECTO FINAL - LENGUAJES FORMALES Y COMPILADORES
================================================================================



CURSO: Lenguajes Formales y Compiladores


================================================================================
                            DESCRIPCI√ìN DEL PROYECTO
================================================================================

Este proyecto implementa un Analizador Sint√°ctico completo para gram√°ticas 
formales, con soporte para parsers LL(1) y SLR(1), adem√°s de un asistente de 
IA integrado que utiliza Ollama para responder preguntas sobre el curso.

================================================================================
                            CARACTER√çSTICAS PRINCIPALES
================================================================================

1. AN√ÅLISIS DE GRAM√ÅTICAS FORMALES
   - C√°lculo de conjuntos FIRST y FOLLOW
   - Generaci√≥n autom√°tica de tablas de parsing LL(1)
   - Generaci√≥n autom√°tica de tablas de parsing SLR(1)
   - Detecci√≥n autom√°tica del tipo de gram√°tica

2. ENTRADA DE GRAM√ÅTICAS (3 M√âTODOS)
   - Formato de proyecto (con contador de l√≠neas)
   - Ingreso manual interactivo
   - Carga desde archivos predefinidos (Sample_ll1.txt, Sample_slr1.txt)

3. AN√ÅLISIS DE CADENAS
   - Prueba de cadenas con la gram√°tica cargada
   - Muestra din√°mica de tokens disponibles
   - Validaci√≥n con ejemplos autom√°ticos

4. ASISTENTE DE IA INTEGRADO
   - Chat interactivo con Ollama (modelo llama3:latest)
   - Contexto del curso cargado autom√°ticamente
   - Responde preguntas sobre Lenguajes Formales y Compiladores
   - Historial de conversaci√≥n

================================================================================
                            ESTRUCTURA DEL PROYECTO
================================================================================

ProyectoFinal-LenguajesFormales/
‚îÇ
‚îú‚îÄ‚îÄ main.py                          # Archivo principal con men√∫ interactivo
‚îÇ
‚îú‚îÄ‚îÄ grammar/                         # M√≥dulo de an√°lisis gramatical
‚îÇ   ‚îú‚îÄ‚îÄ grammar_module.py            # Clase Grammar para representar gram√°ticas
‚îÇ   ‚îú‚îÄ‚îÄ first_follow.py              # C√°lculo de conjuntos FIRST y FOLLOW
‚îÇ   ‚îú‚îÄ‚îÄ ll1_parser.py                # Generador de tablas LL(1)
‚îÇ   ‚îî‚îÄ‚îÄ slr1_parser.py               # Generador de tablas SLR(1)
‚îÇ
‚îú‚îÄ‚îÄ ai_assistant/                    # M√≥dulo de asistente de IA
‚îÇ   ‚îú‚îÄ‚îÄ neural_interface.py          # Interfaz con Ollama
‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îÇ
‚îú‚îÄ‚îÄ data/                            # Archivos de datos
‚îÇ   ‚îú‚îÄ‚îÄ course_content.txt           # Contenido del curso 
‚îÇ   ‚îú‚îÄ‚îÄ Sample_ll1.txt               # Gram√°tica de ejemplo LL(1)
‚îÇ   ‚îî‚îÄ‚îÄ Sample_slr1.txt              # Gram√°tica de ejemplo SLR(1)
‚îÇ
‚îú‚îÄ‚îÄ README.md                        # Documentaci√≥n principal
‚îú‚îÄ‚îÄ ASISTENTE_IA_README.md          # Documentaci√≥n del asistente IA
‚îî‚îÄ‚îÄ DOCUMENTACION_PROYECTO.txt      # Este archivo

================================================================================
                        DETALLES T√âCNICOS IMPORTANTES
================================================================================

S√çMBOLOS ESPECIALES:
--------------------
- Epsilon (cadena vac√≠a): Œµ
- S√≠mbolo de fin: $
- S√≠mbolos no terminales: May√∫sculas (S, A, B, etc.)
- S√≠mbolos terminales: Min√∫sculas y s√≠mbolos (a, b, +, *, etc.)

FORMATO DE GRAM√ÅTICAS:
----------------------
Ejemplo de archivo de gram√°tica:

    5
    S -> A B
    A -> a A | Œµ
    B -> b B | Œµ
    # L√≠neas en blanco son ignoradas

La primera l√≠nea contiene el n√∫mero de producciones.
Cada producci√≥n usa el formato: NO_TERMINAL -> PRODUCCION
El s√≠mbolo | separa alternativas
El s√≠mbolo Œµ representa la cadena vac√≠a

ALGORITMOS IMPLEMENTADOS:
-------------------------
1. FIRST(X):
   - Si X es terminal: FIRST(X) = {X}
   - Si X -> Œµ: a√±adir Œµ a FIRST(X)
   - Si X -> Y1 Y2 ... Yn: calcular recursivamente

2. FOLLOW(A):
   - A√±adir $ a FOLLOW del s√≠mbolo inicial
   - Para A -> Œ±BŒ≤: a√±adir FIRST(Œ≤) - {Œµ} a FOLLOW(B)
   - Si Œ≤ puede derivar Œµ: a√±adir FOLLOW(A) a FOLLOW(B)

3. LL(1) Parser (Top-Down):
   - M[A,a] contiene A -> Œ± si:
     * a est√° en FIRST(Œ±), o
     * Œµ est√° en FIRST(Œ±) y a est√° en FOLLOW(A)

4. SLR(1) Parser (Bottom-Up):
   - Construcci√≥n de aut√≥mata LR(0)
   - Tabla ACTION y GOTO
   - Estados can√≥nicos con items LR

================================================================================
                        TECNOLOG√çAS UTILIZADAS
================================================================================

LENGUAJE:
---------
- Python 3.x

LIBRER√çAS PRINCIPALES:
---------------------
- requests: Comunicaci√≥n HTTP con Ollama
- json: Manejo de datos JSON
- os: Operaciones del sistema operativo

HERRAMIENTAS EXTERNAS:
---------------------
- Ollama (https://ollama.ai): Motor de IA local
- Modelo: llama3:latest (8B par√°metros, 4.66 GB)

================================================================================
                            MEN√ö DEL PROGRAMA
================================================================================

El programa presenta un men√∫ interactivo con 9 opciones:

1. Ingresar gram√°tica en formato de proyecto
   - Solicita n√∫mero de producciones
   - Ingreso manual de cada producci√≥n
   - Validaci√≥n autom√°tica

2. Ingresar gram√°tica manualmente
   - Ingreso libre de producciones
   - Termina con l√≠nea vac√≠a

3. Cargar gram√°tica desde archivo
   - Opci√≥n r√°pida para Sample_ll1.txt
   - Opci√≥n r√°pida para Sample_slr1.txt
   - Ingreso manual de ruta personalizada

4. Calcular FIRST y FOLLOW
   - Muestra la gram√°tica utilizada
   - Calcula y muestra conjuntos FIRST
   - Calcula y muestra conjuntos FOLLOW

5. Generar tabla de parsing
   - Muestra la gram√°tica utilizada
   - Detecta autom√°ticamente el tipo (LL1 o SLR1)
   - Genera y muestra la tabla correspondiente

6. Probar cadena
   - Muestra la gram√°tica utilizada
   - Muestra tokens disponibles con ejemplos
   - Solicita cadena de entrada
   - Valida con el parser correspondiente

7. Mostrar gram√°tica actual
   - Muestra todas las producciones cargadas

8. Asistente de IA con Ollama
   - Chat interactivo sobre el curso
   - Contexto autom√°tico del contenido del curso
   - Comandos: 'salir', 'limpiar', 'ayuda'

9. Salir
   - Cierra el programa

================================================================================
                        USO DEL ASISTENTE DE IA
================================================================================

PREREQUISITOS:
--------------
1. Instalar Ollama desde https://ollama.ai/download
2. Ejecutar: ollama serve
3. Descargar modelo: ollama pull llama3:latest

COMANDOS DEL CHAT:
------------------
- 'salir': Termina el chat y vuelve al men√∫
- 'limpiar': Limpia el historial de conversaci√≥n
- 'ayuda': Muestra comandos disponibles

EJEMPLOS DE PREGUNTAS:
----------------------
- "¬øQu√© es una gram√°tica libre de contexto?"
- "Expl√≠came la diferencia entre LL(1) y SLR(1)"
- "¬øC√≥mo se calcula el conjunto FIRST?"
- "¬øQu√© es un aut√≥mata finito?"
- "Expl√≠came el proceso de compilaci√≥n"
- "¬øQui√©n es el profesor del curso?"

FUNCIONAMIENTO:
---------------
El asistente carga autom√°ticamente el archivo course_content.txt que contiene
toda la informaci√≥n del curso (profesor, objetivos, temas, etc.) y la utiliza
como contexto para responder preguntas de manera precisa y contextualizada.

================================================================================
                        EJEMPLOS DE GRAM√ÅTICAS
================================================================================

EJEMPLO 1: GRAM√ÅTICA LL(1) SIMPLE
----------------------------------
5
S -> A B
A -> a A | Œµ
B -> b B | Œµ

Esta gram√°tica genera cadenas de la forma: a^n b^m (n,m >= 0)

EJEMPLO 2: GRAM√ÅTICA DE EXPRESIONES
------------------------------------
6
E -> T E'
E' -> + T E' | Œµ
T -> F T'
T' -> * F T' | Œµ
F -> ( E ) | id

Esta gram√°tica representa expresiones aritm√©ticas con precedencia de operadores.

EJEMPLO 3: GRAM√ÅTICA SLR(1)
---------------------------
3
S' -> S
S -> L = R | R
L -> * R | id
R -> L

Esta gram√°tica reconoce asignaciones y referencias.

================================================================================
                        PROCESO DE AN√ÅLISIS SINT√ÅCTICO
================================================================================

FLUJO GENERAL:
--------------
1. Cargar/Ingresar Gram√°tica
   ‚Üì
2. Calcular FIRST y FOLLOW (autom√°tico)
   ‚Üì
3. Construir Tabla de Parsing (LL1 o SLR1)
   ‚Üì
4. Analizar Cadena de Entrada
   ‚Üì
5. Aceptar o Rechazar

AN√ÅLISIS LL(1):
---------------
- Parser predictivo descendente
- Usa pila expl√≠cita
- Decisiones basadas en FIRST y FOLLOW
- Tabla M[NO_TERMINAL, TERMINAL]

AN√ÅLISIS SLR(1):
----------------
- Parser ascendente (shift-reduce)
- Usa aut√≥mata LR(0) con estados
- Decisiones de shift/reduce basadas en FOLLOW
- Tablas ACTION y GOTO

================================================================================
                        CASOS DE PRUEBA RECOMENDADOS
================================================================================

PARA GRAM√ÅTICA LL(1) (Sample_ll1.txt):
--------------------------------------
Cadenas v√°lidas:
- "Œµ" (cadena vac√≠a)
- "a"
- "b"
- "aa"
- "bb"
- "aab"
- "abb"
- "aaabbb"

Cadenas inv√°lidas:
- "ba" (b antes de a)
- "aba" (intercaladas)
- "c" (s√≠mbolo no en el alfabeto)

PARA GRAM√ÅTICA SLR(1) (Sample_slr1.txt):
----------------------------------------
Cadenas v√°lidas:
- "id"
- "* id"
- "id = id"
- "id = * id"
- "* id = id"

Cadenas inv√°lidas:
- "="
- "* * id"
- "id id"

================================================================================
                        CONCEPTOS CLAVE DEL CURSO
================================================================================

GRAM√ÅTICAS:
-----------
- Definici√≥n formal: G = (VN, VT, P, S)
  * VN: Vocabulario no terminal
  * VT: Vocabulario terminal
  * P: Conjunto de producciones
  * S: S√≠mbolo inicial

- Jerarqu√≠a de Chomsky:
  * Tipo 0: Sin restricciones
  * Tipo 1: Sensibles al contexto
  * Tipo 2: Libres de contexto (este proyecto)
  * Tipo 3: Regulares

AUT√ìMATAS:
----------
- Aut√≥mata Finito Determinista (AFD)
- Aut√≥mata Finito No Determinista (AFND)
- Aut√≥mata de Pila (AP)
- M√°quina de Turing (MT)

COMPILADORES:
-------------
Fases de compilaci√≥n:
1. An√°lisis L√©xico (Scanner)
2. An√°lisis Sint√°ctico (Parser) ‚Üê ESTE PROYECTO
3. An√°lisis Sem√°ntico
4. Generaci√≥n de C√≥digo Intermedio
5. Optimizaci√≥n
6. Generaci√≥n de C√≥digo

================================================================================
                        INSTRUCCIONES DE EJECUCI√ìN
================================================================================

INSTALACI√ìN:
------------
1. Aseg√∫rate de tener Python 3.x instalado
2. Instala dependencias:
   pip install requests

3. (Opcional) Para el asistente de IA:
   - Descarga Ollama de https://ollama.ai/download
   - Ejecuta: ollama serve
   - Descarga el modelo: ollama pull llama3:latest

EJECUCI√ìN:
----------
1. Abre terminal en la carpeta del proyecto
2. Ejecuta: python main.py
3. Selecciona una opci√≥n del men√∫ (1-9)
4. Sigue las instrucciones en pantalla

FLUJO DE TRABAJO T√çPICO:
------------------------
1. Cargar gram√°tica (opci√≥n 1, 2 o 3)
2. Calcular FIRST y FOLLOW (opci√≥n 4)
3. Generar tabla de parsing (opci√≥n 5)
4. Probar cadenas (opci√≥n 6)
5. (Opcional) Consultar al asistente de IA (opci√≥n 8)

================================================================================
                        CARACTER√çSTICAS AVANZADAS
================================================================================

DETECCI√ìN AUTOM√ÅTICA:
--------------------
El programa detecta autom√°ticamente si una gram√°tica es LL(1) o SLR(1) al
generar la tabla de parsing, intentando primero LL(1) y luego SLR(1) si falla.

VALIDACI√ìN DE ENTRADA:
---------------------
- Verifica formato de producciones
- Detecta s√≠mbolos no definidos
- Valida estructura de gram√°ticas
- Manejo robusto de errores

INTERFAZ AMIGABLE:
------------------
- Men√∫ interactivo con emojis
- Mensajes claros y descriptivos
- Colores y formato para mejor legibilidad
- Ejemplos contextuales din√°micos

OPTIMIZACIONES:
---------------
- C√°lculo eficiente de FIRST y FOLLOW
- Cach√© de resultados intermedios
- Manejo eficiente de memoria

================================================================================
                        LIMITACIONES Y CONSIDERACIONES
================================================================================

LIMITACIONES:
-------------
1. Solo soporta gram√°ticas libres de contexto
2. LL(1) y SLR(1) son subconjuntos de todas las GLC
3. Algunas gram√°ticas ambiguas no pueden ser analizadas
4. El asistente de IA requiere conexi√≥n a Ollama local

CONSIDERACIONES:
----------------
1. Los nombres de no terminales deben ser √∫nicos
2. El s√≠mbolo inicial debe aparecer en las producciones
3. Los archivos deben estar en codificaci√≥n UTF-8
4. Ollama consume recursos significativos (RAM, CPU)

POSIBLES MEJORAS FUTURAS:
-------------------------
1. Soporte para gram√°ticas LR(1) y LALR(1)
2. Visualizaci√≥n gr√°fica de √°rboles de derivaci√≥n
3. Exportaci√≥n de tablas a diferentes formatos
4. Interfaz gr√°fica (GUI)
5. An√°lisis de ambig√ºedad
6. Generador autom√°tico de c√≥digo

================================================================================
                        REFERENCIAS Y RECURSOS
================================================================================

BIBLIOGRAF√çA DEL CURSO:
-----------------------
- Aho, Sethi, Ullman: "Compiladores: Principios, T√©cnicas y Herramientas"
- Hopcroft, Motwani, Ullman: "Introducci√≥n a la Teor√≠a de Aut√≥matas"


RECURSOS EN L√çNEA:
------------------
- Ollama: https://ollama.ai
- Python Documentation: https://docs.python.org
- Gram√°ticas Formales: https://en.wikipedia.org/wiki/Formal_grammar

HERRAMIENTAS RELACIONADAS:
--------------------------
- ANTLR: Generador de parsers
- Yacc/Bison: Generador de parsers LR
- Lex/Flex: Generador de analizadores l√©xicos

================================================================================
                        CR√âDITOS Y AGRADECIMIENTOS
================================================================================







Curso: Lenguajes Formales y Compiladores

TECNOLOG√çAS:
------------
- Python 3.x
- Ollama 
- Visual Studio Code
- GitHub Copilot (asistencia en desarrollo)



================================================================================
                        NOTAS FINALES
================================================================================

Este proyecto representa una implementaci√≥n completa de analizadores sint√°cticos
para gram√°ticas libres de contexto, combinando algoritmos cl√°sicos de la teor√≠a
de compiladores con tecnolog√≠a moderna de IA.

El asistente de IA integrado demuestra c√≥mo las herramientas de inteligencia
artificial pueden mejorar la experiencia de aprendizaje al proporcionar un
tutor virtual disponible 24/7 con conocimiento espec√≠fico del curso.

El c√≥digo est√° estructurado de manera modular, facilitando su comprensi√≥n,
mantenimiento y extensi√≥n futura.

================================================================================
                        FIN DE LA DOCUMENTACI√ìN
================================================================================
Fecha de √∫ltima actualizaci√≥n: Octubre 28, 2025
Versi√≥n: 1.0


